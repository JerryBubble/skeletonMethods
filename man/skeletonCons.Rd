% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/skeletonCons.R
\name{skeletonCons}
\alias{skeletonCons}
\title{Construct the knots and edges for the skeleton representation of a dataset}
\usage{
skeletonCons(
  data,
  centers = NULL,
  labels = NULL,
  k = NA,
  rep = 1000,
  wedge = "all",
  h = NA,
  hadj = 1/5,
  kernel = "gaussian",
  R0 = NA,
  idx_frustum = T
)
}
\arguments{
\item{data}{a matrix/dataframe of data points.}

\item{centers}{an optional matrix/dataframe of the knots in the skeleton representation.}

\item{labels}{an optional numeric vector of skeleton membership labels for each data points.}

\item{k}{a number indication the numer of knots to use for skeleton representation.}

\item{rep}{a number indicating the repetition when overfitting kmeans to choose knots.}

\item{wedge}{a character or a vector of characters indicating the types of edge measure weights to include.
Can take 'all', 'none', 'voronoi', 'face', 'frustum', 'avedist'.}

\item{h}{a number for the bandwidth when using KDE to calculate Face or Frustum density.}

\item{hadj}{a number adjusting the rate of bandwidth with sample size}

\item{kernel}{a character string giving the smoothing kernel to be used in KDE. Same as in the density function. This must partially match one of "gaussian", "rectangular", "triangular", "epanechnikov", "biweight", "cosine" or "optcosine", with default "gaussian", and may be abbreviated to a unique prefix.}

\item{R0}{a number indicating the disk radius for Frustum density}

\item{idx_frustum}{logical; if TRUE, use same disk radius for different pairs of knots. If FALSE, use different within cluster variance as radius}
}
\value{
A list with following components:
\describe{
\item{centers}{The matrix of the skeleton knots.}
\item{cluster}{The numeric vector indicating the neareast knot for each point.}
\item{nknots}{The number indicating the number of knots.}
\item{voron_weights}{The matrix of Voronoi density weights for edges in the skeleton.}
\item{face_weights}{The matrix of Face density weights for edges in the skeleton.}
\item{frustum_weights}{The matrix of Tube/Frustum density weights for edges in the skeleton.}
\item{avedist_weights}{The matrix of Average Distance weights for edges in the skeleton.}
\item{bw}{The bandwidth used for Face and Frustum density calculation. }
\item{R}{The disk radius used for Frustum density calculation. }
}
}
\description{
Construct the knots and edges for the skeleton representation of a dataset
}
\examples{
###create ring data
n_c = 200
n_r=1000
sd_c = 0.1
sd_r = 0.1
d=2
sd_high = 0.1
c_lab = c(rep(1,n_r), rep(2,n_c))
th = runif(n_r,0,2*pi)
x  = cos(th)
y  = sin(th)
X  = cbind(x,y) + matrix(rnorm(2*length(x), sd=sd_r), ncol=2)
u = matrix(rnorm(2*n_c, sd=sd_c), ncol=2)
X0 = rbind(X, u) #created Ring data
###Construct skeleton representation
skeleton = skeletonCons(X0, rep = 1000)
### Voronoi density
F_NNden_tmp = max(skeleton$voron_weights) - skeleton$voron_weights
diag(F_NNden_tmp) = 0
F_NNden_tmp = as.dist(F_NNden_tmp)
F_NNden_hclust = hclust(F_NNden_tmp, method="single") #used average distance instead
plot(F_NNden_hclust, main = 'Cluster Dendrogram with Single Linkage')
F_NNden_lab = cutree(F_NNden_hclust, k=2)
X_lab_F_NNden = F_NNden_lab[skeleton$cluster]
plot(X[,1], X[,2], col = X_lab_F_NNden+1, pch = 19)
}
